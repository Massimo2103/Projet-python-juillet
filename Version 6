from ftplib import FTP
import os
import socket
import sys
import shutil


# connexion au serveur FTP
"""
ftp_host = '127.0.0.1'
ftp_login = 'MARSEILLE'
ftp_password = 'Marseille'
path_ftp = "C:/REMOTE_PROJET/MARSEILLE"
print("Avant connexion")
connexion = FTP (ftp_host, ftp_login, ftp_password)
print("Apr√®s connexion")
print(connexion.getwelcome()) # R√©cup√©rer le message
"""
#connexion.quit()

def ip_valide(Hote): # D√©finition de l'adresse IP
    try: # Essaye
        socket.inet_aton(Hote) # Convertir l'adresse IP en binaire.
        print("L'adresse IP "+ str(Hote) +" est valide.") # Afficher le message si l'adresse IP est valide.
        return 0 # Retourner la valeur 0.
    except socket.error: # Interception de l'erreur li√© au r√©seau.
        print("Erreur : L'adresse IP "+ str(Hote) +" n'est pas valide.") # Afficher le message si l'adresse IP n'est pas valide.
        return 1 # Retourner la valeur 1.
    
def ip_input(): # D√©finition demande et ping de l'adresse IPV4.

    Hote = input("Quelle est l'adresse IPv4 de l'√©quipement concen√© ? : ") # Demander l'adresse IPV4 de l'√©quipement. 
    Response = ip_valide(Hote) # V√©rification de la validit√© de l'adresse IPV4.
    if Response == 0: # Si la d√©fnition pr√©cendente renvoie la valeur 0.
        Response = os.system("ping -n 1 " + Hote ) # Ping avec 1 pacquet vers l'adresse IP.

        if Response == 0: # Si le ping r√©ussi.
            return Hote # Retourner l'adresse IP de l'√©quipement.
        
        else: # Sinon
            print ("") # Afficher ligne vide.
            print("Adresse IP incorrect! ") # Afficher message d'erreur.
            return ip_input() # Demander l'adresse IPV4 valide.
        
    else: # Sinon
        print ("") # Afficher ligne vide.
        print("Adresse IP incorrect ou PING √©chou√© ! ") # Afficher message d'erreur.
        return ip_input() # Demander l'adresse IPV4 valide.

def acceder_ftp():
    hote = '127.0.0.1'
    ftp_login = 'MARSEILLE'
    ftp_password = 'Marseille'
    path_ftp = "/REMOTE_PROJET/MARSEILLE"  # Chemin sur le serveur FTP

    print("Avant connexion")
    try:
        connexion = FTP(hote)  # Connexion √† l'h√¥te
        connexion.login(user=ftp_login, passwd=ftp_password)  # Authentification
        print("Apr√®s connexion")
        print(connexion.getwelcome())  # Message de bienvenue

        # (Optionnel) Se d√©placer dans un r√©pertoire sp√©cifique du serveur
        #connexion.cwd(path_ftp)
        print(f"R√©pertoire actuel : {connexion.pwd()}")

    except Exception as e:
        print(f"Erreur de connexion FTP : {e}")

    #finally:
        if 'connexion' in locals():
            connexion.quit()


def copier_fichier_dossier():

    print("\n Copie FICHIER/DOSSIER ")
    ip_input()
     
    while True :
          try: 
               choix = input("Souhaitez-vous copier un fichier (1) ou un dossier (2) ? : ")
               if choix not in ("1", "2"):
                    raise ValueError("La valeur saisie n'est pas 1 ou 2 ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
               source = input("Entrez le chemin COMPLET du fichier ou du dossier √† copier (ex : C/Massimo/Paris.txt): ").strip()
               if not os.path.exists(source):
                    raise ValueError("Le chemin SOURCE est incorrect ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
               destination = input("Entrez le chemin COMPLET o√π coller le fichier ou le dossier avec le nom du fichier (ex : C/Massimo/Juillet/Paris.txt) : ").strip()
               dossier_parent = os.path.dirname(destination)
               if not os.path.isdir(dossier_parent):
                    raise ValueError("Le chemin de DESTINATION est incorrect ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.

               if choix == "1":
                    shutil.copy2(source, destination)
                    print(f"Fichier copi√© avec succ√®s vers : {destination}")
               elif choix == "2":
                    shutil.copytree(source, destination)
                    print(f"Dossier copi√© avec succ√®s vers : {destination}")
               
          except ValueError as e:
               message_erreur = str(e) # Convertir l'erreur en cha√Æne de caract√®re.
               print(f"Erreur : {message_erreur}") # Afficher le message d'erreur li√© √† l'erreur rencontr√©e.
               
          except Exception as e:
               print(f"Erreur lors de la copie : {e}")

          finally:
               break

def renommer_fichier_dossier():
    print("\n Renommer FICHIER/DOSSIER ")
     
    while True :
        try:      
                choix_server_hote = input("sur ftp (1) ou client (2) ? ")
                if choix_server_hote not in ("1", "2"):
                    raise ValueError("La valeur saisie n'est pas 1 ou 2 ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
                if choix_server_hote == "1" :
                    acceder_ftp()
                elif choix_server_hote == "2" :
                    ip_input()

                choix = input("Souhaitez-vous renommer un fichier (1) ou un dossier (2) ? : ")
                if choix not in ("1", "2"):
                    raise ValueError("La valeur saisie n'est pas 1 ou 2 ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
                ancien_nom = input("Entrez le chemin COMPLET du fichier ou du dossier √† renommer (ex : C/Massimo/Paris): ").strip()
                if not os.path.exists(ancien_nom):
                    raise ValueError("Le chemin est incorrect ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
                
                nouveau_nom = input("Entrez le chemin COMPLET du fichier ou du dossier √† renommer (ex : C/Massimo/Juillet/Paris) : ").strip()
               
                dossier_parent = os.path.dirname(nouveau_nom)
                if not os.path.isdir(dossier_parent):
                    raise ValueError("Le chemin est incorrect ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
               
                os.rename(ancien_nom, nouveau_nom)

                if choix == "1":
                    print(f"Fichier renomm√© avec succ√®s : {ancien_nom} ==> {nouveau_nom}")
                elif choix == "2":
                    print(f"Dossier renomm√© avec succ√®s : {ancien_nom} ==> {nouveau_nom}")
               
        except ValueError as e:
               message_erreur = str(e) # Convertir l'erreur en cha√Æne de caract√®re.
               print(f"Erreur : {message_erreur}") # Afficher le message d'erreur li√© √† l'erreur rencontr√©e.

        except Exception as e:
               print(f"Erreur lors de la renomm√©e : {e}")
               #continue
        else:
            continue


def creer_fichier_dossier():
    print("\n Cr√©er FICHIER/DOSSIER ")

    while True:
        try:
            choix_server_hote = input("sur ftp (1) ou client (2) ? ")
            if choix_server_hote == "1" :
                acceder_ftp()
            elif choix_server_hote == "2" :
                ip_input()
            if choix_server_hote not in ("1", "2"):
                raise ValueError("La valeur saisie n'est pas 1 ou 2 ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
            choix = input("Souhaitez-vous cr√©er un fichier (1) ou un dossier (2) ? : ")
            if choix not in ("1", "2"):
                raise ValueError("La valeur saisie n'est pas 1 ou 2 !")
            localisation = input("Entrez le chemin COMPLET o√π cr√©er le fichier ou dossier (ex : /REMOTE_PROJET/MARSEILLE/Projet ; /REMOTE_PROJET/MARSEILLE/Projet.txt) : ").strip()
            if not localisation:
                 raise ValueError("La localisation n'a pas √©t√© renseign√©e !")
            dossier_parent = os.path.dirname(localisation)
            if not os.path.isdir(dossier_parent):
                raise ValueError("Le dossier parent n'existe pas !")

            if choix == "1":
                with open(localisation, 'x') as f:  # 'x' pour cr√©er uniquement s'il n'existe pas
                    pass
                print(f"Fichier cr√©√© avec succ√®s : {localisation}")

            elif choix == "2":
                os.makedirs(localisation, exist_ok=False)  # erreur si existe d√©j√†
                print(f"Dossier cr√©√© avec succ√®s : {localisation}")

        except ValueError as e:
            message_erreur = str(e) # Convertir l'erreur en cha√Æne de caract√®re.
            print(f"Erreur : {message_erreur}")
        except FileExistsError:
            print("Erreur : Le fichier ou dossier existe d√©j√†.")
        except Exception as e:
            print(f"Erreur lors de la cr√©ation : {e}")
            continue
        else:
            break

def deplacer_fichier_dossier():
    print("\n D√©placer FICHIER/DOSSIER ")

    while True:
        try:
            choix_server_hote = input("sur ftp (1) ou client (2) ? ")
            if choix_server_hote == "1" :
                acceder_ftp()
            elif choix_server_hote == "2" :
                ip_input()
            if choix_server_hote not in ("1", "2"):
                raise ValueError("La valeur saisie n'est pas 1 ou 2 ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.
            choix = input("Souhaitez-vous d√©placer un fichier (1) ou un dossier (2) ? : ")
            if choix not in ("1", "2"):
                raise ValueError("La valeur saisie n'est pas 1 ou 2 !")
            ancien_chemin = input("Entrez le chemin COMPLET du fichier ou dossier √† d√©placer (ex : C:/Massimo/Paris ou C:/Massimo/projet.txt : ").strip()
            if not os.path.exists(ancien_chemin):
                raise ValueError("Le chemin est incorrect !")
            nouveau_chemin = input("Entrez le chemin COMPLET de destination (ex : C:/Massimo/Juillet/Paris ou C:/Massimo/projet.txt) : ").strip()
            dossier_parent = os.path.dirname(nouveau_chemin)
            if not os.path.isdir(dossier_parent):
                raise ValueError("Le chemin de DESTINATION est incorrect !")

            shutil.move(ancien_chemin, nouveau_chemin)

            if choix == "1":
                print(f"Fichier d√©plac√© avec succ√®s : {ancien_chemin} ==> {nouveau_chemin}")
            elif choix == "2":
                print(f"Dossier d√©plac√© avec succ√®s vers : {ancien_chemin} ==> {nouveau_chemin}")

        except ValueError as e:
            print(f"Erreur : {e}")
        except Exception as e:
            print(f"Erreur lors du d√©placement : {e}")
        else:
            break

def supprimer_fichier_dossier():
    print("\ Supprimer FICHIER/DOSSIER ")

    choix_server_hote = input("sur ftp (1) ou client (2) ? ")
     
    if choix_server_hote == "1" :
        acceder_ftp()
    elif choix_server_hote == "2" :
        ip_input()
    
    while True:
        try:
            choix = input("Souhaitez-vous supprimer un fichier (1) ou un dossier (2) ? : ")
            if choix not in ("1", "2"):
               raise ValueError("La valeur saisie n'est pas 1 ou 2 !")
            chemin = input("Entrez le chemin COMPLET du fichier ou du dossier √† supprimer (ex : C:/Massimo/Paris.txt ou C:/Massimo/MonDossier) : ").strip()
            if not os.path.exists(chemin):
               raise ValueError("Le chemin sp√©cifi√© n'existe pas !")

            confirmation = input("√ätes-vous certain de vouloir supprim√© cet √©l√©ment et son contenu ? (o/n): ")
            if confirmation == "o" :
                if choix == "1":
                    if not os.path.isfile(chemin):
                        raise ValueError("Le chemin renseign√© ne renvoie pas un fichier !")
                    os.remove(chemin)
                    print(f"Fichier supprim√© avec succ√®s : {chemin}")

                elif choix == "2":
                    if not os.path.isdir(chemin):
                        raise ValueError("Le chemin renseign√© ne renvoie pas un dossier !")
                    shutil.rmtree(chemin)
                    print(f"Dossier supprim√© avec succ√®s : {chemin}")
            else : 
                print("La suppression a √©t√© annul√©e !")

        except ValueError as e:
            print(f" Erreur : {e}")
        except Exception as e:
            print(f"Erreur lors de la suppression de l'√©l√©ment ! : {e}")
            continue
        else:
            break


def lister_arborescence(chemin, prefixe=""):
    try:
        for element in os.listdir(chemin):
            chemin_complet = os.path.join(chemin, element)
            if os.path.isdir(chemin_complet):
                print(f"{prefixe}[D] {element}/")
                lister_arborescence(chemin_complet, prefixe + "    ")
            else:
                print(f"{prefixe}[F] {element}")
    except Exception as e:
        print(f"Erreur : {e}")

    def main():
        chemin = input("Entrez le chemin du dossier √† lister : ").strip()
        prefixe = input("Entrez le pr√©fixe d'indentation (exemple : 4 espaces ou tab) ou laissez vide : ")
        lister_arborescence(chemin, prefixe)

    if __name__ == "__main__":
     main()

# lister_arborescence("C:/Users/Moi/Documents")


def lister_dossier_fichier2():
    print("\n lister FICHIER/DOSSIER ")

    ip_input()
    
    while True:
        try:
            chemin = input("Saisissez le chemin √† lister (ex : C:/Massimo/Paris) : ").strip()
            if not os.path.isdir(chemin):
                raise ValueError("Le chemin est incorrect ou n'existe pas ! ") # Arr√™t de l'√©xecution et d√©claration de valueError.

            # Liste le contenu du dossier parent de l'ancien chemin
            liste = os.path.dirname(chemin)
            print(f"\nContenu du dossier parent ({liste}) :")
            with os.scandir(liste) as it:
                for entry in it:
                    type_entree = "Dossier" if entry.is_dir() else "Fichier"
                    print(f" - [{type_entree}] {entry.name}")

        except ValueError as e:
            print(f"Erreur : {e}")

        except Exception as e:
            print(f"Erreur lors de la renomm√©e : {e}")
            continue

        else:
            break



def naviguer_arborescence():
    print("\n Naviguer dans l'arborescence des r√©pertoires ")


    try: 
        chemin = input("Saisissez le chemin (ex : C:/Massimo/Paris) : ").strip()
        if not os.path.isdir(chemin):
            raise ValueError("Le chemin indiqu√© n'existe pas ou n'est pas un dossier !")
        print(f"\n Contenu de : {chemin}")

        while True:
            try:
                elements = os.listdir(chemin)
                dossiers = [d for d in elements if os.path.isdir(os.path.join(chemin, d))]
                fichiers = [f for f in elements if os.path.isfile(os.path.join(chemin, f))]

                print("\n ========== DOSSIERS ==========")
                for idx, d in enumerate(dossiers):
                    print(f"  {idx + 1}. {d}")

                print("\n ========== FICHIERS ==========")
                for f in fichiers:
                    print(f"  - {f}")

                print("\n ========== OPTIONS ==========")
                print("  num√©ro  - Acc√©der √† un sous-dossier")
                print("  ..      - Revenir au dossier parent")
                print("  quitter - Quitter la navigation")

                choix = input("\nEntrez votre choix : ").strip()

                if choix == "quitter":
                    print("Fin de la navigation dans l'arborescence.")
                    break
                elif choix == "..":
                    nouveau_chemin = os.path.dirname(chemin)
                    if os.path.isdir(nouveau_chemin):
                        chemin = nouveau_chemin
                    else:
                        print(" Impossible de remonter plus haut.")
                elif choix.isdigit() and 1 <= int(choix) <= len(dossiers):
                    chemin = os.path.join(chemin, dossiers[int(choix) - 1])
                else:
                    print("Choix invalide. Essayez encore.")

            except Exception as e:
                print(f"Erreur : {e}")
    except ValueError as e:
                print(f"Erreur : {e}")



def naviguer_arborescence2():
    print("\n Naviguer dans l'arborescence des r√©pertoires ")

    ip_input()

    while True:
        try: 
            chemin = input("Saisissez le chemin (ex : C:/Massimo/Paris) : ").strip()
            if not os.path.isdir(chemin):
                raise ValueError("Le chemin indiqu√© n'existe pas ou n'est pas un dossier !")
            print(f"\n Contenu de : {chemin}")

            while True:
                try:
                    # Lister tout ce qu'il y a dans le dossier actuel
                    contenu = os.listdir(chemin)

                    # S√©parer les dossiers et les fichiers
                    fichiers = []
                    dossiers = []

                    for element in contenu: # Pour chaque √©lement qui se trouve dans contenu
                        chemin_complet = os.path.join(chemin, element) # chemin complet correspond au chemin de d√©part jusqu'√† √©l√©ment s√©lectionner.
                        if os.path.isfile(chemin_complet): # Si c'est un fichier, alors on l'ajoute √† la liste "fichiers".
                            fichiers.append(element) # Ajout de l'√©l√©ment √† la liste.
                        elif os.path.isdir(chemin_complet): # Si c'est un dossier, alors on l'ajoute √† la liste "dossiers".
                            dossiers.append(element) # Ajout de l'√©l√©ment √† la liste.

                    # Affichage du contenu
                    print(f"\n Contenu de : {chemin}")
                    print("\n========== DOSSIERS ==========")
                    for index, nom_dossier in enumerate(dossiers): # Boucle for pour chaque dossier les num√©rot√©s.
                        print(f"  {index + 1}. {nom_dossier}") # Afficher le num√©ro associ√© au dossier.

                    print("\n========== FICHIERS ==========")
                    for nom_fichier in fichiers: # Boucle for pour chaque dossier les num√©rot√©s.
                        print(f"  - {nom_fichier}") # Afficher le fichier.

                    # Afficher les options disponibles
                    print("\n========== OPTIONS ==========")
                    print("  num√©ro : Aller dans un sous-dossier")
                    print("    ..   : Revenir au dossier pr√©c√©dent")
                    print("    q    : Fermer l'explorateur")

                    # Demander √† l'utilisateur ce qu'il veut faire
                    choix = input("\nüëâ Que voulez-vous faire ? ").strip()

                    if choix.isdigit(): # Si la valeur saisie est un chiffre entier positif.
                        numero = int(choix) # Convertir la valeur par un entier.
                        if 1 <= numero <= len(dossiers): # Si le num√©ro saisi est pr√©sent dans la liste √©num√©r√©e.
                            # Aller dans le sous-dossier choisi
                            sous_dossier = dossiers[numero - 1]
                            chemin = os.path.join(chemin, sous_dossier)
                        else:
                            print("Num√©ro de dossier invalide !")
                    
                    elif choix == "..":
                        dossier_parent = os.path.dirname(chemin)
                        if os.path.isdir(dossier_parent):
                                chemin = dossier_parent
                        else:
                            print("‚ö†Ô∏è Vous √™tes d√©j√† tout en haut !")

                    elif choix == "q":
                        print("üëã Merci d'avoir utilis√© l'explorateur. √Ä bient√¥t !")
                        break   # Quitte la boucle
                            
                    else:
                        print("‚ö†Ô∏è Je n'ai pas compris votre choix. Essayez encore.")

                except Exception as erreur:
                    print(f"üö® Une erreur est survenue : {erreur}")
        except ValueError as erreur:
                print(f"Une erreur s'est produite : {erreur}")




def lister_dossier_fichier():
    print("\nLister les DOSSIERS, les SOUS-DOSSIERS et les FICHIERS")

    ip_input()

    while True:
        try:
            chemin = input("Saisissez le chemin √† lister (ex : C:/Massimo/Paris) : ").strip()
            if not os.path.isdir(chemin):
                raise ValueError("Le chemin est incorrect ou n'existe pas !")

            dossiers = []
            sous_dossiers = []
            fichiers = []

            # Parcours r√©cursif de l'arborescence
            for racine, dirs, files in os.walk(chemin):
                if racine == chemin:
                    # Dossiers directement dans le dossier principal
                    for d in dirs:
                        dossiers.append(os.path.join(racine, d))
                else:
                    # Sous-dossiers
                    for d in dirs:
                        sous_dossiers.append(os.path.join(racine, d))
                # Fichiers
                for f in files:
                    fichiers.append(os.path.join(racine, f))

            # Affichage clair et s√©par√©
            print(f"\nüìÅ Dossiers dans {chemin} :")
            for d in dossiers:
                print(f" - {d}")

            print(f"\nüìÇ Sous-dossiers :")
            for sd in sous_dossiers:
                print(f" - {sd}")

            print(f"\nüìÑ Fichiers :")
            for f in fichiers:
                print(f" - {f}")

        except ValueError as e:
            print(f"Erreur : {e}")

        except Exception as e:
            print(f"Erreur inattendue : {e}")
            continue

        else:
            break





def sauvegarder_fichier_dossiervrai():
    print("\nüì§ COPIE FICHIER/DOSSIER EN LOCAL VERS SERVEUR FTP\n")

    try:
        acceder_ftp()  # Connexion FTP g√©r√©e √† l'int√©rieur (pas assign√©e ici)
        ip_input()

        ftp = acceder_ftp
        
        choix = input("Souhaitez-vous copier un fichier (1) ou un dossier (2) ? : ").strip()
        if choix not in ("1", "2"):
            raise ValueError("La valeur saisie n'est pas 1 ou 2.")
        
        source_local = input("Entrez le chemin COMPLET LOCAL du fichier ou dossier √† copier : ").strip()
        destination_ftp = input("Entrez le chemin COMPLET de DESTINATION sur le serveur FTP (ex : /REMOTE_PROJET/MARSEILLE) : ").strip()

        if not os.path.exists(source_local):
            raise ValueError("‚ùå Le chemin SOURCE est incorrect ou inexistant.")
        
        parent_ftp = os.path.dirname(destination_ftp.rstrip('/'))
        #ftp.cwd("/")  # Revenir √† la racine FTP
        dossiers = ftp.nlst()
        if parent_ftp.strip("/") and parent_ftp.strip("/") not in dossiers:
            raise ValueError("Le chemin de DESTINATION distant n'existe pas sur le serveur FTP.")

        if choix == "1":
            nom_fichier = os.path.basename(source_local)
            chemin_ftp_fichier = destination_ftp if destination_ftp.endswith(nom_fichier) else os.path.join(destination_ftp, nom_fichier)

            ftp.cwd(parent_ftp if parent_ftp else "/")

            print(f"\nüì§ Transfert du fichier '{source_local}' vers '{chemin_ftp_fichier}' ...")
            with open(source_local, "rb") as f:
                ftp.storbinary(f"STOR {nom_fichier}", f)
            print(f"‚úÖ Fichier copi√© avec succ√®s vers : {chemin_ftp_fichier}")

        elif choix == "2":
            print("\n‚ùå Copier un dossier n‚Äôest pas support√© sans cr√©ation automatique des dossiers distants.")
            print("Veuillez cr√©er manuellement le dossier sur le serveur FTP avant la copie.")

    except ValueError as e:
        print(f"Erreur : {e}")
    except Exception as e:
        print(f"Erreur lors de la copie : {e}")

import os
from ftplib import FTP


def acceder_ftp3():
    """Fonction pour se connecter au serveur FTP"""
    try:
        ftp = FTP()
        ftp.connect('127.0.0.1', 21)  # Remplacer par l'IP et le port de ton serveur FTP
        ftp.login('MARSEILLE', 'Marseille')   # Remplacer par tes identifiants FTP
        print("‚úÖ Connexion FTP r√©ussie.")
        
        # Activer le mode passif si n√©cessaire
        ftp.set_pasv(True)
        
        return ftp
    except Exception as e:
        print(f"‚ùå Erreur de connexion FTP : {e}")
        return None

def sauvegarder_fichier_dossier():
    
    print("\nüì§ COPIE FICHIER/DOSSIER EN LOCAL VERS SERVEUR FTP\n")

    try:
        # Connexion FTP
        ftp = acceder_ftp3()  # Appel de la fonction pour se connecter
        if ftp is None:
            raise ValueError("‚ùå Impossible de se connecter au serveur FTP.")
        
        # Demande √† l'utilisateur de choisir un fichier ou un dossier
        choix = input("Souhaitez-vous copier un fichier (1) ou un dossier (2) ? : ").strip()
        if choix not in ("1", "2"):
            raise ValueError("La valeur saisie n'est pas 1 ou 2.")
        
        # Demande des chemins locaux et distants
        source_local = input("Entrez le chemin COMPLET LOCAL du fichier ou dossier √† copier : ").strip()
        destination_ftp = input("Entrez le chemin COMPLET de DESTINATION sur le serveur FTP (ex : /REMOTE_PROJET/MARSEILLE) : ").strip()

        if not os.path.exists(source_local):
            raise ValueError("‚ùå Le chemin SOURCE est incorrect ou inexistant.")
        
        # Normalisation du chemin de destination pour FTP
        #destination_ftp = destination_ftp.strip().replace("\\", "/")  # Normaliser le chemin
        #if not destination_ftp.startswith("/"):
         #   destination_ftp = "/" + destination_ftp  # Ajouter le / au d√©but du chemin s'il n'existe pas
        
        # V√©rification du r√©pertoire distant
        #try:
            ftp.cwd(destination_ftp)  # Tentative de changement de r√©pertoire
            print(f"‚úÖ Le r√©pertoire '{destination_ftp}' existe sur le serveur FTP.")
        #except Exception as e:
            print(f"‚ùå Le r√©pertoire '{destination_ftp}' n'existe pas ou inaccessible : {e}")
            raise ValueError(f"‚ùå Le r√©pertoire de destination '{destination_ftp}' n'existe pas sur le serveur FTP.")
        
        if choix == "1":
            # Copier un fichier
            nom_fichier = os.path.basename(source_local)
            chemin_ftp_fichier = destination_ftp if destination_ftp.endswith(nom_fichier) else os.path.join(destination_ftp, nom_fichier)

            print(f"\nüì§ Transfert du fichier '{source_local}' vers '{chemin_ftp_fichier}' ...")
            with open(source_local, "rb") as f:
                ftp.storbinary(f"STOR {chemin_ftp_fichier}", f)
            print(f"‚úÖ Fichier copi√© avec succ√®s vers : {chemin_ftp_fichier}")

        elif choix == "2":
            # Copier un dossier
            print("\n‚ùå Copier un dossier n‚Äôest pas support√© dans cette version. Seul les fichiers sont copi√©s.")
            print("Veuillez cr√©er manuellement le dossier sur le serveur FTP avant la copie.")

    except ValueError as e:
        print(f"Erreur : {e}")
    except Exception as e:
        print(f"Erreur lors de la copie : {e}")
    finally:
        if ftp:
            ftp.quit()  # Toujours fermer la connexion FTP

def sauvegarder_fichier_dossierencours():
    
    print("\nüì§ COPIE FICHIER/DOSSIER EN LOCAL VERS SERVEUR FTP\n")

    try:
        # Connexion FTP
        acceder_ftp()
        ftp = acceder_ftp3()  # Appel de la fonction pour se connecter
        #if ftp is None:
        #    raise ValueError("‚ùå Impossible de se connecter au serveur FTP.")
        
        # Demande √† l'utilisateur de choisir un fichier ou un dossier
        choix = input("Souhaitez-vous copier un fichier (1) ou un dossier (2) ? : ").strip()
        if choix not in ("1", "2"):
            raise ValueError("La valeur saisie n'est pas 1 ou 2.")
        
        # Demande des chemins locaux et distants
        source_local = input("Entrez le chemin COMPLET LOCAL du fichier ou dossier √† copier : ").strip()
        destination_ftp = input("Entrez le chemin COMPLET de DESTINATION sur le serveur FTP (ex : /REMOTE_PROJET/MARSEILLE) : ").strip()

        if not os.path.exists(source_local):
            raise ValueError("‚ùå Le chemin SOURCE est incorrect ou inexistant.")
        
        if not os.path.exists(destination_ftp):
            raise ValueError("‚ùå Le chemin SOURCE est incorrect ou inexistant.")
        
        # Normalisation du chemin de destination pour FTP
        #destination_ftp = destination_ftp.strip().replace("\\", "/")  # Normaliser le chemin
        #if not destination_ftp.startswith("/"):
         #   destination_ftp = "/" + destination_ftp  # Ajouter le / au d√©but du chemin s'il n'existe pas
        
        # V√©rification du r√©pertoire distant
        #try:
            ftp.cwd(destination_ftp)  # Tentative de changement de r√©pertoire
            print(f"‚úÖ Le r√©pertoire '{destination_ftp}' existe sur le serveur FTP.")
        #except Exception as e:
            print(f"‚ùå Le r√©pertoire '{destination_ftp}' n'existe pas ou inaccessible : {e}")
            raise ValueError(f"‚ùå Le r√©pertoire de destination '{destination_ftp}' n'existe pas sur le serveur FTP.")
                   
        
        if choix == "1":
            # Copier un fichier
            nom_fichier = os.path.basename(source_local)
            chemin_ftp_fichier = destination_ftp if destination_ftp.endswith(nom_fichier) else os.path.join(destination_ftp, nom_fichier)

            print(f"\nüì§ Transfert du fichier '{source_local}' vers '{chemin_ftp_fichier}' ...")
            with open(source_local, "rb") as f:
                ftp.storbinary(f"STOR {chemin_ftp_fichier}", f)
            print(f"‚úÖ Fichier copi√© avec succ√®s vers : {chemin_ftp_fichier}")

        elif choix == "2":
            # Copier un dossie
            
            print(f"\nüìÇ Transfert du dossier '{source_local}' vers le serveur FTP...")
            for root, dirs, files in os.walk(source_local):
                for fichier in files:
                    fichier_local = os.path.join(root, fichier)
                    chemin_ftp_fichier = os.path.join(destination_ftp, os.path.relpath(fichier_local, source_local)).replace("\\", "/")
                    
                    # Assure-toi que le r√©pertoire distant existe avant de copier le fichier
                    try:
                        # On essaie de se rendre dans le r√©pertoire du fichier distant
                        ftp.cwd(os.path.dirname(chemin_ftp_fichier))
                    except Exception as e:
                        # Si on ne peut pas, on cr√©e les dossiers n√©cessaires
                        ftp.mkd(os.path.dirname(chemin_ftp_fichier))
                        ftp.cwd(os.path.dirname(chemin_ftp_fichier))
                    
                    # Copie le fichier
                    print(f"\nüì§ Transfert du fichier '{fichier_local}' vers '{chemin_ftp_fichier}' ...")
                    with open(fichier_local, "rb") as f:
                        ftp.storbinary(f"STOR {chemin_ftp_fichier}", f)
                    print(f"‚úÖ Fichier '{fichier_local}' copi√© avec succ√®s vers : {chemin_ftp_fichier}")

            print(f"‚úÖ Dossier '{source_local}' copi√© avec succ√®s vers le serveur FTP.")

    except ValueError as e:
        print(f"Erreur : {e}")
    except Exception as e:
        print(f"Erreur lors de la copie : {e}")
    finally:
        if ftp:
            ftp.quit()  # Toujours fermer la connexion FTP







def sauvegarder_fichier_dossier2():
    print("\nüì§ COPIE FICHIER/DOSSIER EN LOCAL VERS path_ftp\n")

    try:
        acceder_ftp()
        ip_input()
        choix = input("Souhaitez-vous copier un fichier (1) ou un dossier (2) ? : ").strip()
        if choix not in ("1", "2"):
            raise ValueError("La valeur saisie n'est pas 1 ou 2 !")
        source = input("Entrez le chemin COMPLET du fichier ou du dossier √† copier : ").strip()
        if not os.path.exists(source):
            raise ValueError("‚ùå Le chemin SOURCE est incorrect !")


        # D√©finir le chemin de destination automatiquement
        #nom_element = os.path.basename(source)
        #destination = os.path.join(path_ftp, nom_element)

        if choix == "1":
            shutil.copy2(source, destination)
            print(f"‚úÖ Fichier copi√© avec succ√®s vers : {destination}")
        else:
            if os.path.exists(destination):
                print(f"‚ö†Ô∏è Le dossier '{destination}' existe d√©j√†. Suppression avant copie.")
                shutil.rmtree(destination)
            shutil.copytree(source, destination)
            print(f"‚úÖ Dossier copi√© avec succ√®s vers : {destination}")

    except ValueError as ve:
        print(f"Erreur : {ve}")
    except Exception as e:
        print(f"‚ùå Une erreur s'est produite : {e}")
        


def acceder_ftp3():
    """Fonction pour se connecter au serveur FTP"""
    try:
        ftp = FTP()
        ftp.connect('127.0.0.1', 21)  # Remplacer par l'IP et le port de ton serveur FTP
        ftp.login('MARSEILLE', 'Marseille')   # Remplacer par tes identifiants FTP
        print("‚úÖ Connexion FTP r√©ussie.")
        
        # Activer le mode passif si n√©cessaire
        ftp.set_pasv(True)
        
        return ftp
    except Exception as e:
        print(f"‚ùå Erreur de connexion FTP : {e}")
        return None

def restaurer_fichier_dossier():
    print("\nüì§ RESTAURER FICHIER/DOSSIER DE SERVEUR FTP VERS CLIENT\n")

    try:
        
        ftp = acceder_ftp3()  # Appel de la fonction pour se connecter
        if ftp is None:
            raise ValueError("‚ùå Impossible de se connecter au serveur FTP.")
        
        ip_input()
  
        choix = input("Souhaitez-vous restaurer un fichier (1) ou un dossier (2) ? : ").strip()
        if choix not in ("1", "2"):
            raise ValueError("La valeur saisie n'est pas 1 ou 2.")
        
        # Demande du chemin du fichier/dossier sur le serveur FTP
        source_ftp = input("Entrez le chemin COMPLET du fichier ou dossier √† restaurer sur le serveur FTP : ").strip()

        # Demande du chemin de destination local sur le PC distant
        destination_local = input(f"Entrez le chemin COMPLET LOCAL de destination sur le PC distant : ").strip()

        # V√©rifier si la source FTP existe
        try:
            ftp.cwd(source_ftp)  # V√©rifier si le r√©pertoire source existe
            est_dossier = True
        except Exception:
            # Si √ßa √©choue, c'est un fichier
            est_dossier = False
        
        # Si le chemin local n'existe pas, cr√©er le r√©pertoire local
        if not os.path.exists(destination_local):
            os.makedirs(destination_local)  # Cr√©er le dossier local si il n'existe pas
        
        if choix == "1" and not est_dossier:

            # T√©l√©charger un fichier depuis le serveur FTP
            nom_fichier = os.path.basename(source_ftp)
            destination_fichier_local = os.path.join(destination_local, nom_fichier)
            
            print(f"\nüì§ R√©cup√©ration du fichier '{source_ftp}' vers '{destination_fichier_local}' ...")
            with open(destination_fichier_local, "wb") as f:
                ftp.retrbinary(f"RETR {source_ftp}", f.write)
            print(f"‚úÖ Fichier restaur√© avec succ√®s vers : {destination_fichier_local}")

        elif choix == "2" and est_dossier:
            # T√©l√©charger un dossier depuis le serveur FTP
            print(f"\nüìÇ R√©cup√©ration du dossier '{source_ftp}' vers '{destination_local}' ...")
            
            # Fonction r√©cursive pour r√©cup√©rer les fichiers dans le dossier distant
            def recuperer_dossier_ftp(ftp, source_dossier_ftp, destination_dossier_local):
                try:
                    # Lister les fichiers dans le r√©pertoire distant
                    ftp.cwd(source_dossier_ftp)
                    fichiers = ftp.nlst()
                    
                    for fichier in fichiers:
                        fichier_distant = os.path.join(source_dossier_ftp, fichier).replace("\\", "/")
                        chemin_local_fichier = os.path.join(destination_dossier_local, fichier)
                        
                        # Si c'est un fichier, le t√©l√©charger
                        try:
                            # Essayer de t√©l√©charger le fichier
                            with open(chemin_local_fichier, "wb") as f:
                                ftp.retrbinary(f"RETR {fichier_distant}", f.write)
                            print(f"‚úÖ Fichier '{fichier_distant}' restaur√© avec succ√®s vers : {chemin_local_fichier}")
                        except Exception:
                            # Si c'est un dossier, l'explorer r√©cursivement
                            os.makedirs(chemin_local_fichier, exist_ok=True)
                            recuperer_dossier_ftp(ftp, fichier_distant, chemin_local_fichier)

                except Exception as e:
                    print(f"Erreur lors de la r√©cup√©ration du dossier {source_dossier_ftp}: {e}")

            # Lancer la r√©cup√©ration du dossier
            recuperer_dossier_ftp(ftp, source_ftp, destination_local)
            print(f"‚úÖ Dossier '{source_ftp}' restaur√© avec succ√®s vers : {destination_local}")

        else:
            print("‚ùå Le choix ou le type de fichier/dossier est incorrect.")

    except ValueError as e:
        print(f"Erreur : {e}")
    except Exception as e:
        print(f"Erreur lors de la restauration : {e}")
    finally:
        if ftp:
            ftp.quit()  # Toujours fermer la connexion FTP


def restaurer_fichier_dossierencours():
    print("\nüì§ RESTAURER FICHIER/DOSSIER DE SERVEUR FTP VERS CLIENT\n")

    try:
        
        ftp = acceder_ftp3()  # Appel de la fonction pour se connecter
        if ftp is None:
            raise ValueError("‚ùå Impossible de se connecter au serveur FTP.")
        
        ip_input()
  
        choix = input("Souhaitez-vous restaurer un fichier (1) ou un dossier (2) ? : ").strip()
        if choix not in ("1", "2"):
            raise ValueError("La valeur saisie n'est pas 1 ou 2.")
        
        # Demande du chemin du fichier/dossier sur le serveur FTP
        source_ftp = input("Entrez le chemin COMPLET du fichier ou dossier √† restaurer sur le serveur FTP : ").strip()

        # Demande du chemin de destination local sur le PC distant
        destination_local = input(f"Entrez le chemin COMPLET LOCAL de destination sur le PC distant : ").strip()

        # V√©rifier si la source FTP existe
        #try:
        #    ftp.cwd(source_ftp)  # V√©rifier si le r√©pertoire source existe
         #   est_dossier = True
       # except Exception:
            # Si √ßa √©choue, c'est un fichier
          #  est_dossier = False
        
        # Si le chemin local n'existe pas, cr√©er le r√©pertoire local
        if not os.path.exists(destination_local):
            os.makedirs(destination_local)  # Cr√©er le dossier local si il n'existe pas
        
        if choix == "1" :

            # T√©l√©charger un fichier depuis le serveur FTP
            nom_fichier = os.path.basename(source_ftp)
            destination_fichier_local = os.path.join(destination_local, nom_fichier)
            
            print(f"\nüì§ R√©cup√©ration du fichier '{source_ftp}' vers '{destination_fichier_local}' ...")
            with open(destination_fichier_local, "wb") as f:
                ftp.retrbinary(f"RETR {source_ftp}", f.write)
            print(f"‚úÖ Fichier restaur√© avec succ√®s vers : {destination_fichier_local}")

        elif choix == "2":
            # T√©l√©charger un dossier depuis le serveur FTP
            print(f"\nüìÇ R√©cup√©ration du dossier '{source_ftp}' vers '{destination_local}' ...")
            
            # Fonction r√©cursive pour r√©cup√©rer les fichiers dans le dossier distant
            def recuperer_dossier_ftp(ftp, source_dossier_ftp, destination_dossier_local):
                try:
                    # Lister les fichiers dans le r√©pertoire distant
                    ftp.cwd(source_dossier_ftp)
                    fichiers = ftp.nlst()
                    
                    for fichier in fichiers:
                        fichier_distant = os.path.join(source_dossier_ftp, fichier).replace("\\", "/")
                        chemin_local_fichier = os.path.join(destination_dossier_local, fichier)
                        
                        # Si c'est un fichier, le t√©l√©charger
                        try:
                            # Essayer de t√©l√©charger le fichier
                            with open(chemin_local_fichier, "wb") as f:
                                ftp.retrbinary(f"RETR {fichier_distant}", f.write)
                            print(f"‚úÖ Fichier '{fichier_distant}' restaur√© avec succ√®s vers : {chemin_local_fichier}")
                        except Exception:
                            # Si c'est un dossier, l'explorer r√©cursivement
                            os.makedirs(chemin_local_fichier, exist_ok=True)
                            recuperer_dossier_ftp(ftp, fichier_distant, chemin_local_fichier)

                except Exception as e:
                    print(f"Erreur lors de la r√©cup√©ration du dossier {source_dossier_ftp}: {e}")

            # Lancer la r√©cup√©ration du dossier
            recuperer_dossier_ftp(ftp, source_ftp, destination_local)
            print(f"‚úÖ Dossier '{source_ftp}' restaur√© avec succ√®s vers : {destination_local}")

        else:
            print("‚ùå Le choix ou le type de fichier/dossier est incorrect.")

    except ValueError as e:
        print(f"Erreur : {e}")
    except Exception as e:
        print(f"Erreur lors de la restauration : {e}")
    finally:
        if ftp:
            ftp.quit()  # Toujours fermer la connexion FTP




def gestion_fichier():

 while True : # Tant que c'est vrai.
        
        print("============================================================") # Afficher le choix.
        print("Que souhaitez-vous faire ?") # Afficher le choix.
        print("")
        print("1 : COPIER un fichier ou un dossier.") # Afficher le choix.
        print("2 : RENOMMER un fichier ou un dossier.") # Afficher le choix.
        print("3 : CR√âER un fichier ou un dossier.") # Afficher le choix.
        print("4 : D√âPLACER un fichier ou un dossier.") # Afficher le choix.
        print("5 : SUPPRIMER un fichier ou un dossier.") # Afficher le choix.
        print("6 : SAUVEGARDER un fichier ou un dossier (depuis le client).") # Afficher le choix.
        print("7 : RESTAURER un fichier ou un dossier (depuis le serveur).") # Afficher le choix.
        print("8 : QUITTER.") # Afficher le choix.

        choix = input("Selectionner l'action que vous souhaitez faire : ") # Demander le choix.

        if choix == "1" : # Scanner un port specifique.
             copier_fichier_dossier()
        elif choix == "2" : # Scanner une plage de port.
             renommer_fichier_dossier()
        elif choix == "3" : # Scanner tous les ports simultanement.
             creer_fichier_dossier()
        elif choix == "4" : # Scanner tous les ports simultanement.
             deplacer_fichier_dossier()
        elif choix == "5" : # Scanner tous les ports simultanement.
             supprimer_fichier_dossier()
        elif choix == "6" : # Scanner tous les ports simultanement.
             sauvegarder_fichier_dossierencours()
        elif choix == "7" : # Scanner tous les ports simultanement.
             restaurer_fichier_dossierencours()

        #elif choix == "7" : # Scanner tous les ports simultanement.

        #elif choix == "8" : # Quitter le module.

          #break
             
#if __name__ == "__main__":
gestion_fichier()

     
     
import os
from ftplib import FTP

